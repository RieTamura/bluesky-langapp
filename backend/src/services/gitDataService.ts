import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';
import { WordData, UserData, AppData } from '../types/data.js';
import DataService from './dataService.js';

export interface GitDataExport {
  metadata: {
    exportedAt: string;
    version: string;
    userId?: string;
    totalWords: number;
    totalUsers: number;
  };
  users: UserData[];
  words: WordData[];
  learningProgress: {
    userId: string;
    totalWords: number;
    knownWords: number;
    learningWords: number;
    unknownWords: number;
    averageReviewCount: number;
    lastActivity: string;
  }[];
}

export interface TangledExportFormat {
  format: 'tangled-v1';
  metadata: {
    exportedAt: string;
    source: 'bluesky-langapp';
    version: string;
    userId: string;
    userName?: string;
  };
  vocabulary: {
    word: string;
    status: 'new' | 'learning' | 'mastered';
    addedAt: string;
    lastReviewed?: string;
    reviewCount: number;
    correctCount: number;
    definition?: string;
    example?: string;
    difficulty: number;
    tags: string[];
  }[];
  progress: {
    totalWords: number;
    masteredWords: number;
    learningWords: number;
    newWords: number;
    studyStreak: number;
    lastStudyDate: string;
  };
}

class GitDataService {
  private dataService: DataService;
  private gitDataDir: string;
  private exportsDir: string;

  constructor() {
    this.dataService = new DataService();
    this.gitDataDir = path.resolve(process.cwd(), '..', 'data-git');
    this.exportsDir = path.resolve(process.cwd(), '..', 'exports');
  }

  /**
   * Initialize Git repository for data management
   */
  async initializeGitRepo(): Promise<void> {
    try {
      // Create data-git directory
      await fs.mkdir(this.gitDataDir, { recursive: true });
      await fs.mkdir(this.exportsDir, { recursive: true });

      // Check if git repo already exists
      const gitDir = path.join(this.gitDataDir, '.git');
      try {
        await fs.access(gitDir);
        console.log('Git repository already exists');
        return;
      } catch {
        // Git repo doesn't exist, create it
      }

      // Initialize git repository
      process.chdir(this.gitDataDir);
      execSync('git init', { stdio: 'inherit' });
      
      // Create initial .gitignore
      const gitignoreContent = `# Temporary files
*.tmp
*.temp
.DS_Store
Thumbs.db

# Backup files
*.bak
*.backup

# Log files
*.log
logs/

# Node modules (if any scripts are added)
node_modules/
`;
      await fs.writeFile(path.join(this.gitDataDir, '.gitignore'), gitignoreContent);

      // Create README
      const readmeContent = `# Bluesky LangApp Data Repository

This repository contains learning data managed by Bluesky LangApp.

## Structure

- \`users/\` - User data files
- \`words/\` - Word learning data organized by user
- \`exports/\` - Export files for external integrations
- \`backups/\` - Automated backups with timestamps

## Data Format

All data is stored in JSON format with standardized schemas for compatibility with external tools.

## Version Control

Each significant change to learning data is committed with descriptive messages including:
- User actions (word additions, status changes)
- Learning progress milestones
- Data migrations and updates

## Export Formats

- **Standard JSON**: Native app format
- **Tangled Format**: Compatible with Tangled language learning platform
- **CSV**: For spreadsheet applications
- **Anki**: For Anki flashcard import

Generated by Bluesky LangApp v1.0.0
`;
      await fs.writeFile(path.join(this.gitDataDir, 'README.md'), readmeContent);

      // Initial commit
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "Initial commit: Setup Bluesky LangApp data repository"', { stdio: 'inherit' });

      console.log('Git repository initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Git repository:', error);
      throw error;
    }
  }

  /**
   * Export current data to Git repository
   */
  async exportToGit(userId?: string, commitMessage?: string): Promise<string> {
    try {
      await this.initializeGitRepo();

      const appData = await this.dataService.readAppData();
      const timestamp = new Date().toISOString();

      // Create directory structure
      const usersDir = path.join(this.gitDataDir, 'users');
      const wordsDir = path.join(this.gitDataDir, 'words');
      const backupsDir = path.join(this.gitDataDir, 'backups');

      await fs.mkdir(usersDir, { recursive: true });
      await fs.mkdir(wordsDir, { recursive: true });
      await fs.mkdir(backupsDir, { recursive: true });

      // Export users
      if (userId) {
        const user = appData.users.find(u => u.id === userId);
        if (user) {
          const userFile = path.join(usersDir, `${userId}.json`);
          await fs.writeFile(userFile, JSON.stringify(user, null, 2));
        }
      } else {
        for (const user of appData.users) {
          const userFile = path.join(usersDir, `${user.id}.json`);
          await fs.writeFile(userFile, JSON.stringify(user, null, 2));
        }
      }

      // Export words organized by user
      const userWords = userId 
        ? { [userId]: appData.words.filter(w => w.userId === userId) }
        : appData.words.reduce((acc, word) => {
            const uid = word.userId || 'default';
            if (!acc[uid]) acc[uid] = [];
            acc[uid].push(word);
            return acc;
          }, {} as Record<string, WordData[]>);

      for (const [uid, words] of Object.entries(userWords)) {
        const userWordsDir = path.join(wordsDir, uid);
        await fs.mkdir(userWordsDir, { recursive: true });

        // Group words by status
        const wordsByStatus = words.reduce((acc, word) => {
          if (!acc[word.status]) acc[word.status] = [];
          acc[word.status].push(word);
          return acc;
        }, {} as Record<string, WordData[]>);

        for (const [status, statusWords] of Object.entries(wordsByStatus)) {
          const statusFile = path.join(userWordsDir, `${status}.json`);
          await fs.writeFile(statusFile, JSON.stringify(statusWords, null, 2));
        }

        // Create user summary
        const summary = {
          userId: uid,
          totalWords: words.length,
          statusCounts: {
            unknown: wordsByStatus.unknown?.length || 0,
            learning: wordsByStatus.learning?.length || 0,
            known: wordsByStatus.known?.length || 0
          },
          lastUpdated: timestamp,
          averageReviewCount: words.reduce((sum, w) => sum + (w.reviewCount || 0), 0) / words.length || 0
        };
        
        const summaryFile = path.join(userWordsDir, 'summary.json');
        await fs.writeFile(summaryFile, JSON.stringify(summary, null, 2));
      }

      // Create full backup
      const backupFile = path.join(backupsDir, `backup_${timestamp.replace(/[:.]/g, '-')}.json`);
      await fs.writeFile(backupFile, JSON.stringify(appData, null, 2));

      // Commit changes
      process.chdir(this.gitDataDir);
      execSync('git add .', { stdio: 'inherit' });
      
      const defaultMessage = userId 
        ? `Update data for user ${userId} - ${timestamp}`
        : `Update all data - ${timestamp}`;
      
      const message = commitMessage || defaultMessage;
      execSync(`git commit -m "${message}"`, { stdio: 'inherit' });

      console.log(`Data exported to Git repository: ${message}`);
      return this.gitDataDir;
    } catch (error) {
      console.error('Failed to export to Git:', error);
      throw error;
    }
  }

  /**
   * Create Tangled-compatible export
   */
  async exportForTangled(userId: string): Promise<string> {
    try {
      const appData = await this.dataService.readAppData();
      const user = appData.users.find(u => u.id === userId);
      const userWords = appData.words.filter(w => w.userId === userId);

      if (!user) {
        throw new Error(`User not found: ${userId}`);
      }

      // Convert to Tangled format
      const tangledExport: TangledExportFormat = {
        format: 'tangled-v1',
        metadata: {
          exportedAt: new Date().toISOString(),
          source: 'bluesky-langapp',
          version: '1.0.0',
          userId: user.id,
          userName: user.displayName
        },
        vocabulary: userWords.map(word => ({
          word: word.word,
          status: word.status === 'known' ? 'mastered' : word.status === 'learning' ? 'learning' : 'new',
          addedAt: word.date,
          lastReviewed: word.lastReviewedAt,
          reviewCount: word.reviewCount || 0,
          correctCount: word.correctCount || 0,
          definition: word.definition,
          example: word.exampleSentence,
          difficulty: word.difficultyLevel || 1,
          tags: ['bluesky', 'imported']
        })),
        progress: {
          totalWords: userWords.length,
          masteredWords: userWords.filter(w => w.status === 'known').length,
          learningWords: userWords.filter(w => w.status === 'learning').length,
          newWords: userWords.filter(w => w.status === 'unknown').length,
          studyStreak: 0, // Would need to calculate from learning sessions
          lastStudyDate: userWords.reduce((latest, word) => {
            const wordDate = word.lastReviewedAt || word.date;
            return wordDate > latest ? wordDate : latest;
          }, '1970-01-01T00:00:00.000Z')
        }
      };

      // Save export file
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const exportFileName = `tangled-export-${userId}-${timestamp}.json`;
      const exportPath = path.join(this.exportsDir, exportFileName);
      
      await fs.writeFile(exportPath, JSON.stringify(tangledExport, null, 2));

      console.log(`Tangled export created: ${exportFileName}`);
      return exportPath;
    } catch (error) {
      console.error('Failed to create Tangled export:', error);
      throw error;
    }
  }

  /**
   * Create CSV export for spreadsheet applications
   */
  async exportToCSV(userId?: string): Promise<string> {
    try {
      const appData = await this.dataService.readAppData();
      const words = userId 
        ? appData.words.filter(w => w.userId === userId)
        : appData.words;

      // CSV headers
      const headers = [
        'Word',
        'Status',
        'User ID',
        'Date Added',
        'Definition',
        'Example Sentence',
        'Review Count',
        'Correct Count',
        'Last Reviewed',
        'Difficulty Level'
      ];

      // Convert words to CSV rows
      const csvRows = [
        headers.join(','),
        ...words.map(word => [
          `"${word.word}"`,
          word.status,
          word.userId || '',
          word.date,
          `"${word.definition || ''}"`,
          `"${word.exampleSentence || ''}"`,
          word.reviewCount || 0,
          word.correctCount || 0,
          word.lastReviewedAt || '',
          word.difficultyLevel || 1
        ].join(','))
      ];

      const csvContent = csvRows.join('\n');

      // Save CSV file
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const fileName = userId 
        ? `words-export-${userId}-${timestamp}.csv`
        : `words-export-all-${timestamp}.csv`;
      const exportPath = path.join(this.exportsDir, fileName);
      
      await fs.writeFile(exportPath, csvContent, 'utf-8');

      console.log(`CSV export created: ${fileName}`);
      return exportPath;
    } catch (error) {
      console.error('Failed to create CSV export:', error);
      throw error;
    }
  }

  /**
   * Get Git repository status
   */
  async getGitStatus(): Promise<{
    initialized: boolean;
    lastCommit?: string;
    uncommittedChanges: boolean;
    totalCommits: number;
  }> {
    try {
      const gitDir = path.join(this.gitDataDir, '.git');
      
      try {
        await fs.access(gitDir);
      } catch {
        return {
          initialized: false,
          uncommittedChanges: false,
          totalCommits: 0
        };
      }

      process.chdir(this.gitDataDir);

      // Get last commit
      let lastCommit: string | undefined;
      try {
        lastCommit = execSync('git log -1 --format="%H %s %ad" --date=iso', { encoding: 'utf-8' }).trim();
      } catch {
        lastCommit = undefined;
      }

      // Check for uncommitted changes
      let uncommittedChanges = false;
      try {
        const status = execSync('git status --porcelain', { encoding: 'utf-8' });
        uncommittedChanges = status.trim().length > 0;
      } catch {
        uncommittedChanges = false;
      }

      // Get total commits
      let totalCommits = 0;
      try {
        const commitCount = execSync('git rev-list --count HEAD', { encoding: 'utf-8' });
        totalCommits = parseInt(commitCount.trim(), 10) || 0;
      } catch {
        totalCommits = 0;
      }

      return {
        initialized: true,
        lastCommit,
        uncommittedChanges,
        totalCommits
      };
    } catch (error) {
      console.error('Failed to get Git status:', error);
      return {
        initialized: false,
        uncommittedChanges: false,
        totalCommits: 0
      };
    }
  }

  /**
   * List available exports
   */
  async listExports(): Promise<{
    fileName: string;
    filePath: string;
    size: number;
    createdAt: string;
    type: 'tangled' | 'csv' | 'json';
  }[]> {
    try {
      await fs.mkdir(this.exportsDir, { recursive: true });
      const files = await fs.readdir(this.exportsDir);
      
      const exports = [];
      for (const fileName of files) {
        const filePath = path.join(this.exportsDir, fileName);
        const stats = await fs.stat(filePath);
        
        let type: 'tangled' | 'csv' | 'json' = 'json';
        if (fileName.includes('tangled-export')) type = 'tangled';
        else if (fileName.endsWith('.csv')) type = 'csv';
        
        exports.push({
          fileName,
          filePath,
          size: stats.size,
          createdAt: stats.birthtime.toISOString(),
          type
        });
      }
      
      return exports.sort((a, b) => b.createdAt.localeCompare(a.createdAt));
    } catch (error) {
      console.error('Failed to list exports:', error);
      return [];
    }
  }
}

export default GitDataService;